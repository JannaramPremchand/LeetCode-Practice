package Depth_First_Search;

import java.util.*;

public class MinimizeMalwareSpread {
  public static void main(String[] args) {
    int[][] graph = {
      {1, 0, 0, 0, 0, 0},
      {0, 1, 0, 0, 0, 0},
      {0, 0, 1, 0, 0, 0},
      {0, 0, 0, 1, 1, 0},
      {0, 0, 0, 1, 1, 0},
      {0, 0, 0, 0, 0, 1}
    };
    int[] i = {5, 0};
    new MinimizeMalwareSpread().minMalwareSpread(graph, i);
  }

  Map<Integer, List<Integer>> graphMap;
  Map<Integer, Integer> size;
  Set<Integer> done;
  Map<Integer, Integer> color;
  int count = 0;

  public int minMalwareSpread(int[][] graph, int[] initial) {
    graphMap = new HashMap<>();
    done = new HashSet<>();
    color = new HashMap<>();
    size = new HashMap<>();
    for (int i = 0; i < graph.length; i++) {
      for (int j = 0; j < graph[0].length; j++) {
        if (graph[i][j] == 1) {
          graphMap.putIfAbsent(i, new ArrayList<>());
          graphMap.get(i).add(j);
          graphMap.putIfAbsent(j, new ArrayList<>());
          graphMap.get(j).add(i);
        }
      }
    }
    for (int i : initial) {
      if (!done.contains(i)) {
        count = 0;
        dfs(i, i);
        size.put(i, count);
      }
    }
    List<Integer> eligible = new ArrayList<>();
    boolean candidate;
    for (int i = 0; i < initial.length; i++) {
      int iColor = color.get(initial[i]);
      candidate = true;
      for (int j = 0; j < initial.length; j++) {
        if (j != i) {
          if (color.get(initial[j]) == iColor) {
            candidate = false;
            break;
          }
        }
      }
      if (candidate) {
        eligible.add(initial[i]);
      }
    }
    Arrays.sort(initial);
    eligible.sort(Comparator.comparingInt(o -> o));
    if (eligible.isEmpty()) {
      return initial[0];
    } else {
      int answer = initial[0];
      int max = 0;
      for (int i = 0, l = eligible.size(); i < l; i++) {
        int node = eligible.get(i);
        if (size.containsKey(node)) {
          if (size.get(node) > max) {
            max = size.get(node);
            answer = node;
          }
        }
      }
      return answer;
    }
  }

  private void dfs(int i, int col) {
    done.add(i);
    color.put(i, col);
    count++;
    List<Integer> children = graphMap.get(i);
    if (children != null && !children.isEmpty()) {
      for (int c : children) {
        if (!done.contains(c)) {
          dfs(c, col);
        }
      }
    }
  }
}
